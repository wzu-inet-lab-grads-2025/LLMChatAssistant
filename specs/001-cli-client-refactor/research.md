# 研究文档: CLI客户端重构与验证

**功能**: CLI客户端重构与验证
**日期**: 2026-01-01
**状态**: 已完成

## 研究目标

研究CLI客户端重构的技术方案、最佳实践和潜在风险，确保重构符合项目章程v1.6.0的所有原则。

## 研究主题

### 1. 客户端独立架构

**研究问题**: 如何实现客户端独立部署，同时保持与服务器协议同步？

**研究发现**:
- **最佳实践**: Monorepo模式，客户端和服务器在同一仓库但独立打包
- **协议同步方案**: 客户端维护独立的协议定义副本，通过版本号检查兼容性
- **依赖管理**: 客户端使用独立的pyproject.toml，定义自己的依赖
- **打包策略**: CLI客户端使用Python直接运行，Desktop客户端使用PyInstaller打包

**决策**: 采用独立的协议定义副本

**理由**:
- 支持客户端独立分发和部署
- 用户可以在Windows设备上安装客户端，无需整个服务器代码库
- 客户端依赖与服务器依赖解耦，避免版本冲突

**替代方案及被拒绝原因**:
- 共享协议定义（被拒绝）：会导致部署复杂度增加，客户端无法独立分发
- 使用子模块（被拒绝）：增加维护成本，协议变更需要同步多个仓库

**实施计划**:
1. 复制 protocols/nplt.py 和 protocols/rdt.py 到 clients/cli/protocols/
2. 在协议定义中添加版本号（PROTOCOL_VERSION）
3. 实现版本检查机制：连接时验证客户端和服务器协议版本
4. 建立协议同步流程：协议变更时同步更新客户端和服务器定义

### 2. 100%真实测试策略

**研究问题**: 如何在不使用mock的情况下测试客户端与后端的集成？

**研究发现**:
- **章程要求**: 项目章程v1.6.0明确禁止mock测试，所有测试必须使用真实API
- **智谱AI免费额度**: glm-4-flash和glm-4.5-flash模型提供免费额度，足够测试使用
- **测试环境**: 需要启动真实服务器和真实数据库（storage/、logs/）
- **测试隔离**: 使用临时会话和临时文件，避免测试污染

**决策**: 100%真实测试，零mock

**理由**:
- 真实测试确保代码在真实环境中按预期工作
- Mock测试可能掩盖真实的集成问题，特别是协议通信、文件传输、LLM调用
- 真实API测试验证实际的协议格式、错误处理、数据序列化
- 智谱AI提供免费模型，无需额外成本

**替代方案及被拒绝原因**:
- 使用mock模拟后端（被章程明确禁止）
- 使用伪造的LLM Provider（被章程明确禁止）

**实施计划**:
1. 测试前检查ZHIPU_API_KEY是否配置
2. 启动真实服务器（使用test fixtures）
3. 创建临时测试数据和临时会话
4. 测试完成后清理测试数据
5. 记录详细的测试报告，包括真实的API调用日志

### 3. 重构顺序策略

**研究问题**: 应该先重构再测试，还是先测试再重构？

**研究发现**:
- **风险分析**: 直接重构可能将已知问题带入新架构，难以区分问题来源
- **基线重要性**: 需要建立稳定的重构基线，确保重构前功能正常
- **用户反馈**: 用户明确指出"现有功能不一定全部符合要求"
- **最佳实践**: 先验证修复，再重构，最后回归测试

**决策**: 三阶段顺序执行（验证→修复→重构→再验证）

**理由**:
- 确保重构基线稳定，避免将已知问题带入重构后的代码
- 可以明确区分原有问题和重构引入的问题
- 每个阶段都有明确的验收标准，便于质量控制
- 符合软件工程的最佳实践

**替代方案及被拒绝原因**:
- 直接重构再测试（被拒绝）：风险高，难以区分问题来源
- 边重构边测试（被拒绝）：流程混乱，难以追踪进度

**实施计划**:
1. 阶段1：验证现有功能，生成问题报告
2. 阶段2：修复P0/P1问题，达到100%测试通过率
3. 阶段3：执行目录结构重构
4. 阶段4：回归测试，确保无功能回归

### 4. 目录组织结构

**研究问题**: 如何组织目录结构以支持多客户端和独立部署？

**研究发现**:
- **Monorepo最佳实践**: 客户端、服务器、共享代码分离到顶层目录
- **客户端独立原则**: 客户端代码不依赖src/目录中的服务器代码
- **未来扩展**: 需要为Desktop和Web客户端预留空间
- **测试组织**: 客户端测试、服务器测试、共享模块测试分离

**决策**: clients/, server/, shared/ 顶层分离

**理由**:
- 清晰的模块边界，易于理解和维护
- 支持独立部署，客户端可以单独打包
- 符合monorepo最佳实践，便于管理多包项目
- 为未来多客户端扩展奠定基础

**替代方案及被拒绝原因**:
- 保持在src/下（被拒绝）：不符合客户端独立原则
- 使用多仓库（被拒绝）：增加维护成本，不便管理

**实施计划**:
1. 创建 clients/ 顶层目录
2. 创建 clients/cli/ 子目录，移动客户端代码
3. 创建 clients/desktop/ 和 clients/web/ 预留目录
4. 移动 server/ 到顶层
5. 创建 shared/ 目录，移动共享代码
6. 保留 src/ 用于纯服务器端工具

### 5. 协议版本管理

**研究问题**: 客户端和服务器协议独立定义后，如何保持同步？

**研究发现**:
- **版本标识**: 在协议定义中添加版本号（PROTOCOL_VERSION）
- **兼容性检查**: 连接时验证版本兼容性
- **不兼容处理**: 拒绝连接并提示用户升级
- **演进策略**: 主版本号不兼容，次版本号向后兼容

**决策**: 客户端和服务器协议独立定义，版本检查验证兼容性

**理由**:
- 允许客户端和服务器独立演进
- 防止不匹配的客户端和服务器通信失败
- 提供清晰的错误提示，帮助用户理解问题
- 支持平滑升级和向后兼容

**替代方案及被拒绝原因**:
- 共享协议定义（被拒绝）：违背客户端独立原则
- 无版本检查（被拒绝）：可能导致通信失败和数据损坏

**实施计划**:
1. 在 protocols/nplt.py 和 protocols/rdt.py 中添加 PROTOCOL_VERSION
2. 实现版本协商机制：连接时交换版本号
3. 检查版本兼容性：主版本号必须相同
4. 不兼容时拒绝连接并返回错误提示
5. 更新协议时同步客户端和服务器定义

## 技术决策总结

| 决策 | 选择 | 理由 | 替代方案 |
|------|------|------|----------|
| 客户端架构 | 独立协议定义副本 | 支持独立部署 | 共享协议定义（被拒绝）|
| 测试策略 | 100%真实测试 | 确保真实集成 | Mock测试（被禁止）|
| 重构顺序 | 先验证再重构 | 建立稳定基线 | 直接重构（高风险）|
| 目录组织 | clients/server/shared分离 | 清晰边界，支持扩展 | 保持在src/下（不符合原则）|
| 版本管理 | 版本号检查机制 | 防止通信失败 | 无版本检查（风险高）|

## 风险评估

| 风险 | 概率 | 影响 | 缓解措施 |
|------|------|------|----------|
| 现有功能存在严重问题 | 中 | 高 | 优先修复P0问题，设置基线快照 |
| 重构后导入路径错误 | 高 | 中 | 自动化脚本批量更新，充分测试 |
| 协议定义不同步 | 中 | 中 | 实施版本检查机制，自动化同步测试 |
| 性能下降 | 低 | 中 | 性能基线测试，持续监控 |
| 测试覆盖不足 | 中 | 高 | 强制100%功能覆盖，代码审查 |

## 最佳实践参考

### Monorepo管理
- **参考项目**: Babel, Jest, React
- **工具**: uv (依赖管理), pytest (测试)
- **原则**: 清晰的模块边界，独立打包

### Python项目结构
- **参考**: Python项目最佳实践 (https://docs.python-guide.org/)
- **原则**: 客户端、服务器、共享代码分离
- **测试**: 测试文件与源代码放在同一目录

### 客户端-服务器通信
- **协议**: NPLT (TCP聊天), RDT (UDP文件传输)
- **版本管理**: 语义化版本控制 (Semantic Versioning)
- **兼容性**: 向后兼容，主版本号变更时明确通知

## 结论

本研究确认了CLI客户端重构的技术可行性和最佳实践。所有决策符合项目章程v1.6.0的原则，特别是客户端独立性原则、测试真实性原则和配置驱动部署原则。重构风险可控，实施计划清晰。

**下一步**: 进入阶段1（设计与合同），生成数据模型、API契约和快速入门指南。
